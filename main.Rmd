---
title: "main"
author: "Joost Doornbos"
date: "2/7/2022"
output: pdf_document
---


```{r data}
library(readr)
# replaced only the single spaces by underscores, changed `a to a, in notepad++
# data from ftp dot fu-berlin dot de/pub/misc/movies/database/frozendata
# file is ratings dot list dot gz, created at 22 dec 2017 00:00:00
# there was also some text in the middle -- removed that too
df <- readr::read_table("ratingdata.txt", col_names = T,
                        col_types = cols("c", "i", "d", "c"))
df_top <- df[1:250, ]
df_bot <- df[251:260, ]
df_all <- df[261:dim(df)[1], ]
```


```{r functions}
dist_convert <- function(df) {
  require(magrittr)
  
  # convert data into something useable
  x <- df$Distribution %>% strsplit(split = "") %>% unlist()
  x <- replace(x, x==".", "10")
  x <- replace(x, x=="*", "11")
  
  # replace values given in the string by midbpoints of histogram bars
  # e.g., something getting 1-10% of votes is said to have gotten 4.5%
  old <- c(10, 0:9, 11)
  new <- c(0, seq(4.5, 94.5, 10), 100)
  
  # ugly but effective way of converting and replacing the values
  x <- x %>% as.integer() %>% factor(old, new) %>%
             as.character() %>% as.double()
  
  # rescaled to sum to 1 -- it is a pmf
  # I think it would not automatically due to rounding stuff with my 4.5's.
  x <- t(matrix(x, byrow = T, ncol = 10))
  y <- scale(x, F, colSums(x)) %>% t() %>% as.data.frame()
  
  return(y)
  
}

fnorm <- function(x, m = 4.5, s = 1, a = 0, b = 11, p = 0, q = 0) {
  
  # p, q are added to account for people overly giving a 1 or 10,
  # but the params of course should be able to be added
  # (H) reminds it is a human created error msg
  if ((p != 0 | q != 0) & !any(x == 1 | x == 10)) stop("Cannot add p, q (H)")
  
  # necessary to have two values to add p,q to and one in between
  if (!(a < b - 3)) stop("a < b - 3 necessary (H)")
  
  # convert continuous normal pdf into discrete
  # it is centered at integers, since ratings are 1:10
  discnorm <- function(x, m, s) {
  
    ifelse(x %% 1 == 0,
           pnorm(x + 1 / 2, m, s) - pnorm(x - 1 / 2, m, s),
           0)
  
  }
  
  # truncate the above discrete normal dist to be >a and <b
  # a = 0, b = 11 would then give the appropriate range for voting distributions
  dtnorm <- ifelse(x > a & x < b,
                   discnorm(x, m, s) / sum(discnorm((floor(a) + 1):(ceiling(b) - 1), m, s)),
                   0)
  # figure out where to add p, q
  x <- sort(unique(x))
  sc <- numeric(length(x))
  if (any(x==1 | x==10)) {
    
    sc[which(x==1)] <- p
    sc[which(x==10)] <- q
    
  }
  
  return((dtnorm + sc) / (1 + p + q))
  
}
```


```{r old stuff}
tnorm <- function(x, m, s, a, b) {
  
  ifelse(x > a & x < b,
         dnorm(x, m, s) / (pnorm(b, m, s) - pnorm(a, m, s)),
         0)
  
}

discnorm <- function(x, m, s) {
  
  ifelse(x %% 1 == 0,
         pnorm(x + 1 / 2, m, s) - pnorm(x - 1 / 2, m, s),
         0)
  
}

dtnorm <- function(x, m, s, a, b) {
  
  ifelse(x > a & x < b,
         discnorm(x, m, s) / sum(discnorm((floor(a) + 1):(ceiling(b) - 1), m, s)),
         0)
  
}

tdnorm <- function(x, m, s, a, b) {
  
  # check if same as above -- where to cut off?
  
}

fnorm <- function(x, m, s, a = 0, b = 11, p, q) {
  if (!(a < b - 3)) stop("a < b - 3 necessary (H)")
  
  x <- sort(unique(x))
  
  sc <- numeric(length(x))
  
  if (any(x==1 | x==10)) {
    
    sc[which(x==1)]  <- p
    sc[which(x==10)] <- q
    
  }
  
  return((dtnorm(x, m, s, a, b) + sc) / (1 + p + q))
  
}
```


```{r example plots}
plot(seq(1,10), fnorm(seq(1,10), 7.02, 1, 0, 11, 1/50, 1/15), 'h')
plot(seq(1,10), dbinom(seq(0,9), 9, 0.55), 'h')
```


```{r fit parameters to vote distribution top 250}
fit_fun <- function(df, start_params, opt_type, min_type, distr_fun) {
  
  # TODO: add distr_fun = not just fnorm,
  #       add stop for invalid starting parameters
  #       check overlap in opt_types
  
  opt_types <- c("constr_mean", "endpoint_inflation_negative",
                 "endpoint_inflation_positive")
  if (!(opt_type %in% opt_types)) stop("Wrong optim type (H)")
  
  distr_funs <- c("fnorm")
  if (!(distr_fun %in% distr_funs)) stop("Invalid fitting distribution (H)")
  
  min_types <- c("L1", "L2", "CE")
  if (!(min_type %in% min_types)) stop("Invalid loss function (H)")
  
  min_type <- which(min_types == min_type)
  
  distr_fun <- get(distr_fun)
  
  # ps = c(mean, stdev, prob_inflate_bottom, prob_inflate_top)
  # L1, L2 norms and cross-entropy.
  min_funs <- list(L2 = function(ps, values) {
                     sum((distr_fun(1:10, ps[1], ps[2], 0, 11, ps[3], ps[4]) - values)^2)},
    
                   L1 = function(ps, values) {
                     sum(abs(distr_fun(1:10, ps[1], ps[2], 0, 11, ps[3], ps[4]) - values))},
    
                   CE = function(ps, values) {
                     -1 * sum(values * log(distr_fun(1:10, ps[1], ps[2], 0, 11, ps[3], ps[4])))})
  
  min_fun <- min_funs[[min_type]]
  
  if (opt_type == "constr_mean") {
    
    # Constrain the mean to be between 1 and 10.
    return(constrOptim(start_params, min_fun, NULL, rbind(matrix(c(-1, rep(0, 3)), nrow = 1),
                                                          diag(4)), c(-10, rep(0, 4)), values = df))
    
  } else if (opt_type == "endpoint_inflation_negative") {
    
    # Will allow p, q to be negative, as long as f(1)+p and f(10)+q are positive.
    # Not sure if it will ever be useful, and the bounds would be dynamic.
    stop("WIP (H)")
    
  } else if (opt_type == "endpoint_inflation_positive") {
    
    # Constrain the added endpoint inflation >=0.
    return(constrOptim(start_params, min_fun, NULL, cbind(rep(0,3), diag(3)),
                       c(0, 0, 0), values = df))
    
  }
  
}
```


```{r testing}
library(magrittr)
library(tictoc)
tic()
values <- df_top[1, ] %>% dist_convert() %>% as.numeric()
fit_fun(dist_convert(df_top[1, ]), c(4.5, 1, 0.1, 0.1), "constr_mean", "L2",
        "fnorm")
toc()
# TODO: make it (significantly) faster

```

